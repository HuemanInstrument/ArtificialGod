<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ArtificialGod.org</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: #000;
            color: #fff;
            font-family: -apple-system, Arial, sans-serif;
            font-size: 12px;
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        /* Langton's Ant Header */
        .langtons-header {
            position: relative;
            width: 100%;
            height: 120px;
            overflow: hidden;
            z-index: 10;
        }
        
        #langtonsCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* Background canvas */
        #distortionCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        
        /* Main content */
        .container {
            max-width: 480px;
            margin: 0 auto;
            padding: 20px 20px 100px;
            background-color: rgba(0, 0, 0, 0.85);
            min-height: 100vh;
        }
        
        .post {
            margin-bottom: 50px;
            padding-bottom: 30px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .post-date {
            font-size: 10px;
            opacity: 0.5;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }
        
        .post-title {
            font-size: 16px;
            margin-bottom: 15px;
            font-weight: normal;
            letter-spacing: 0.5px;
        }
        
        .post-content {
            font-size: 15px;
            line-height: 1.8;
            opacity: 0.9;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        /* Audio player */
        .audio-player {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: #000;
            border-top: 1px solid #fff;
            padding: 0;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .audio-controls {
            display: none; /* Hide our custom controls */
        }
        
        .play-pause-btn {
            background: none;
            border: 1px solid #fff;
            color: #fff;
            padding: 5px 15px;
            cursor: pointer;
            font-size: 11px;
            opacity: 0.7;
            transition: opacity 0.3s;
        }
        
        .play-pause-btn:hover {
            opacity: 1;
        }
        
        .volume-slider {
            width: 100px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
            cursor: pointer;
        }
        
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            cursor: pointer;
            border-radius: 50%;
        }
        
        .volume-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #fff;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        
        .volume-label {
            color: #fff;
            font-size: 11px;
            opacity: 0.7;
        }
        
        /* Loading message */
        .loading {
            text-align: center;
            padding: 20px;
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <!-- Langton's Ant Animation Header -->
    <div class="langtons-header">
        <canvas id="langtonsCanvas"></canvas>
    </div>
    
    <canvas id="distortionCanvas"></canvas>
    
    <div class="container" id="content">
        <div class="loading">Loading posts...</div>
    </div>
    
    <div class="audio-player">
        <iframe id="ytPlayer" width="100%" height="60" frameborder="0" allow="autoplay"></iframe>
    </div>
    
    <script>
        // Langton's Ant Animation
        const langtonsCanvas = document.getElementById('langtonsCanvas');
        const langtonsCtx = langtonsCanvas.getContext('2d');
        
        // Configuration
        const cellSize = 4;
        let grid;
        let ants = [];
        let gridWidth, gridHeight;
        
        // Text to display
        const text = "Artificial God . Org";
        
        function initLangtonsAnt() {
            langtonsCanvas.width = window.innerWidth;
            langtonsCanvas.height = 120;
            
            gridWidth = Math.floor(langtonsCanvas.width / cellSize);
            gridHeight = Math.floor(langtonsCanvas.height / cellSize);
            
            // Initialize grid (all white initially)
            grid = new Array(gridHeight).fill(null).map(() => new Array(gridWidth).fill(0));
            
            // Create text bitmap
            langtonsCtx.clearRect(0, 0, langtonsCanvas.width, langtonsCanvas.height);
            
            langtonsCtx.fillStyle = 'white';
            langtonsCtx.font = 'bold 32px Arial';
            langtonsCtx.textAlign = 'center';
            langtonsCtx.textBaseline = 'middle';
            
            // Draw the text to get its position
            const textX = langtonsCanvas.width / 2;
            const textY = langtonsCanvas.height / 2;
            langtonsCtx.fillText(text, textX, textY);
            
            // Find the position of the dot in ". org"
            const metrics = langtonsCtx.measureText("Artificial God ");
            const dotX = textX - (langtonsCtx.measureText(text).width / 2) + metrics.width;
            
            // Sample the canvas to create initial grid state
            const imageData = langtonsCtx.getImageData(0, 0, langtonsCanvas.width, langtonsCanvas.height);
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const canvasX = x * cellSize + cellSize / 2;
                    const canvasY = y * cellSize + cellSize / 2;
                    const index = (Math.floor(canvasY) * langtonsCanvas.width + Math.floor(canvasX)) * 4;
                    // If pixel is white (text), set grid cell to 1
                    if (imageData.data[index] > 128) {
                        grid[y][x] = 1;
                    }
                }
            }
            
            // Initialize single ant at the dot position
            const antX = Math.floor(dotX / cellSize);
            const antY = Math.floor(textY / cellSize);
            
            ants = [{
                x: antX,
                y: antY,
                direction: 0 // 0: up, 1: right, 2: down, 3: left
            }];
            
            // Draw the initial state immediately
            langtonsCtx.clearRect(0, 0, langtonsCanvas.width, langtonsCanvas.height);
            
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    if (grid[y][x] === 1) {
                        langtonsCtx.fillStyle = 'white';
                        langtonsCtx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }
            
            // Draw the initial ant position
            langtonsCtx.fillStyle = 'white';
            langtonsCtx.fillRect(antX * cellSize - 2, antY * cellSize - 2, cellSize + 4, cellSize + 4);
            langtonsCtx.fillStyle = '#ff0000';
            langtonsCtx.fillRect(antX * cellSize - 1, antY * cellSize - 1, cellSize + 2, cellSize + 2);
        }
        
        function updateLangtonsAnt() {
            // Update each ant
            ants.forEach(ant => {
                if (ant.x >= 0 && ant.x < gridWidth && ant.y >= 0 && ant.y < gridHeight) {
                    // Get current cell color
                    const currentColor = grid[ant.y][ant.x];
                    
                    // Apply Langton's Ant rules
                    if (currentColor === 0) { // Empty/dark cell
                        // Turn right
                        ant.direction = (ant.direction + 1) % 4;
                    } else { // White cell
                        // Turn left
                        ant.direction = (ant.direction + 3) % 4;
                    }
                    
                    // Flip the color
                    grid[ant.y][ant.x] = 1 - currentColor;
                    
                    // Move forward
                    switch (ant.direction) {
                        case 0: ant.y--; break; // Up
                        case 1: ant.x++; break; // Right
                        case 2: ant.y++; break; // Down
                        case 3: ant.x--; break; // Left
                    }
                }
            });
            
            // Draw the grid
            langtonsCtx.clearRect(0, 0, langtonsCanvas.width, langtonsCanvas.height);
            
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    if (grid[y][x] === 1) {
                        langtonsCtx.fillStyle = 'white';
                        langtonsCtx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }
            
            // Draw ant
            if (ants[0] && ants[0].x >= 0 && ants[0].x < gridWidth && ants[0].y >= 0 && ants[0].y < gridHeight) {
                // White outline for visibility
                langtonsCtx.fillStyle = 'white';
                langtonsCtx.fillRect(ants[0].x * cellSize - 2, ants[0].y * cellSize - 2, cellSize + 4, cellSize + 4);
                // Red ant
                langtonsCtx.fillStyle = '#ff0000';
                langtonsCtx.fillRect(ants[0].x * cellSize - 1, ants[0].y * cellSize - 1, cellSize + 2, cellSize + 2);
            }
        }
        
        // Initialize and start Langton's Ant animation
        initLangtonsAnt();
        setInterval(updateLangtonsAnt, 100); // Update every 100ms
        
        // Canvas setup
        const canvas = document.getElementById('distortionCanvas');
        const ctx = canvas.getContext('2d');
        
        // Grid vertices
        let vertices = [];
        let lenses = [];
        let gridSize = 25; // Smaller squares
        let cols, rows;
        let scrollOffset = 0;
        let time = 0;
        let lastLensTime = 0;
        
        // Resize canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Calculate grid dimensions with extra margin
            cols = Math.ceil(canvas.width / gridSize) + 4;
            rows = Math.ceil(canvas.height / gridSize) + 4;
            
            // Initialize vertices
            vertices = [];
            for (let i = 0; i <= cols; i++) {
                vertices[i] = [];
                for (let j = 0; j <= rows; j++) {
                    const x = (i - 2) * gridSize;
                    const y = (j - 2) * gridSize;
                    vertices[i][j] = {
                        x: x,
                        y: y,
                        originalX: x,
                        originalY: y
                    };
                }
            }
        }
        
        // Lens class
        class Lens {
            constructor() {
                this.radius = (Math.random() * 15 + 10) * 25; // Adjusted for smaller grid
                this.x = Math.random() * canvas.width;
                this.y = -this.radius;
                this.speed = (Math.random() * 0.3 + 0.3); // Slower speed
                this.drift = (Math.random() - 0.5) * 0.2;
            }
            
            update() {
                this.y += this.speed;
                this.x += this.drift;
                return this.y < canvas.height + this.radius;
            }
            
            // Apply lens distortion to a vertex
            distortVertex(vertex) {
                const dx = vertex.x - this.x;  // Use current position, not original
                const dy = vertex.y - this.y;  // Use current position, not original
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < this.radius) {
                    // Lens magnification effect
                    const factor = 1 - (distance / this.radius);
                    const magnification = Math.pow(factor, 2) * 0.5; // Smooth falloff
                    
                    // Push vertices away from center (magnify)
                    const angle = Math.atan2(dy, dx);
                    const push = distance * magnification;
                    
                    vertex.x += Math.cos(angle) * push;
                    vertex.y += Math.sin(angle) * push;
                }
            }
        }
        
        // Animation function
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update scroll offset for continuous movement - 4x slower
            scrollOffset += 0.075;
            
            // Smooth wrapping without jumps
            if (scrollOffset >= gridSize * 2) {
                scrollOffset -= gridSize * 2;
            }
            
            // Reset vertices to original positions with scroll offset
            for (let i = 0; i <= cols; i++) {
                for (let j = 0; j <= rows; j++) {
                    const vertex = vertices[i][j];
                    vertex.x = vertex.originalX - scrollOffset;
                    vertex.y = vertex.originalY - scrollOffset;
                }
            }
            
            // Apply lens distortions
            for (let i = 0; i <= cols; i++) {
                for (let j = 0; j <= rows; j++) {
                    const vertex = vertices[i][j];
                    
                    // Apply each lens effect
                    for (const lens of lenses) {
                        lens.distortVertex(vertex);
                    }
                }
            }
            
            // Draw distorted checkerboard
            ctx.fillStyle = '#000011';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    const p1 = vertices[i][j];
                    const p2 = vertices[i + 1][j];
                    const p3 = vertices[i + 1][j + 1];
                    const p4 = vertices[i][j + 1];
                    
                    // Determine if this should be a dark square
                    const offsetSquares = Math.floor(scrollOffset / gridSize);
                    const fractionalOffset = (scrollOffset % gridSize) / gridSize;
                    const isDark = ((i + j + offsetSquares * 2) % 2) === 0;
                    
                    if (isDark) {
                        ctx.fillStyle = 'rgba(11, 0, 0, 1)';
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.lineTo(p3.x, p3.y);
                        ctx.lineTo(p4.x, p4.y);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }
            
            // Update lenses
            lenses = lenses.filter(lens => lens.update());
            
            // Add new lenses with better timing
            if (time - lastLensTime > 180 && lenses.length < 3) { // 3 seconds minimum between lenses
                if (Math.random() < 0.3) {
                    lenses.push(new Lens());
                    lastLensTime = time;
                }
            }
            
            time++;
            requestAnimationFrame(animate);
        }
        
        // Initialize
        window.addEventListener('resize', () => {
            resizeCanvas();
            initLangtonsAnt();
        });
        resizeCanvas();
        
        // Start with some lenses
        for (let i = 0; i < 2; i++) {
            setTimeout(() => lenses.push(new Lens()), i * 2000);
        }
        
        // Start animation
        animate();
        
        // YouTube Player Controls
        let currentVideoId = 'yQmmG2JmnEk'; // Default
        
        // Load text files
        async function loadPosts() {
            const container = document.getElementById('content');
            container.innerHTML = '';
            
            try {
                // Try to load files from Data_0001.txt to Data_9999.txt
                const posts = [];
                let fileNumber = 1;
                let consecutiveFailures = 0;
                
                // Keep trying to load files until we get 5 consecutive failures
                while (consecutiveFailures < 5 && fileNumber < 1000) {
                    const fileName = `Data_${String(fileNumber).padStart(4, '0')}.txt`;
                    
                    try {
                        const response = await fetch(fileName);
                        if (response.ok) {
                            const text = await response.text();
                            posts.push({ number: fileNumber, content: text, fileName: fileName });
                            consecutiveFailures = 0;
                        } else {
                            consecutiveFailures++;
                        }
                    } catch (error) {
                        consecutiveFailures++;
                    }
                    
                    fileNumber++;
                }
                
                // Sort posts by number (descending - highest first)
                posts.sort((a, b) => b.number - a.number);
                
                // Check for YouTube ID in the most recent post
                if (posts.length > 0) {
                    const lines = posts[0].content.split('\n');
                    for (const line of lines) {
                        if (line.startsWith('YOUTUBE:')) {
                            const youtubeId = line.replace('YOUTUBE:', '').trim();
                            if (youtubeId) {
                                currentVideoId = youtubeId;
                            }
                            break;
                        }
                    }
                }
                
                // Set the YouTube video directly in iframe
                document.getElementById('ytPlayer').src = `https://www.youtube.com/embed/${currentVideoId}?autoplay=1&loop=1&playlist=${currentVideoId}&controls=1&modestbranding=1`;
                
                // Display posts
                if (posts.length > 0) {
                    posts.forEach(post => {
                        const postDiv = document.createElement('div');
                        postDiv.className = 'post';
                        
                        // Extract YouTube ID for this post
                        let youtubeId = '';
                        const lines = post.content.split('\n');
                        lines.forEach(line => {
                            if (line.startsWith('YOUTUBE:')) {
                                youtubeId = line.split(':')[1].trim();
                                console.log('Found YouTube ID in post:', youtubeId); // Debug
                            }
                        });
                        postDiv.dataset.youtube = youtubeId; // Store in data attribute
                        console.log('Post created with data-youtube:', postDiv.dataset.youtube); // Debug
                        
                        // Filter out YOUTUBE: lines from display
                        const displayLines = lines.filter(line => !line.startsWith('YOUTUBE:'));
                        
                        let dateHtml = '';
                        let contentStart = 0;
                        
                        // Check if first line looks like a date
                        if (displayLines[0] && displayLines[0].match(/\d{4}-\d{2}-\d{2}|JANUARY|FEBRUARY|MARCH|APRIL|MAY|JUNE|JULY|AUGUST|SEPTEMBER|OCTOBER|NOVEMBER|DECEMBER/i)) {
                            dateHtml = `<div class="post-date">${displayLines[0].toUpperCase()}</div>`;
                            contentStart = 1;
                        }
                        
                        // Check if second line looks like a title
                        let titleHtml = '';
                        if (displayLines[contentStart] && displayLines[contentStart].length > 0 && displayLines[contentStart].length < 100) {
                            titleHtml = `<div class="post-title">${displayLines[contentStart]}</div>`;
                            contentStart++;
                        }
                        
                        // Rest is content
                        const content = displayLines.slice(contentStart).join('\n').trim();
                        
                        postDiv.innerHTML = `
                            ${dateHtml}
                            ${titleHtml}
                            <div class="post-content">${content}</div>
                        `;
                        
                        container.appendChild(postDiv);
                    });
                    
                    // Set up intersection observer for scrolling
                    console.log('Setting up scroll observer...'); // Debug
                    setupScrollObserver();
                } else {
                    container.innerHTML = '<div class="post"><div class="post-content">No posts found. Add text files named Data_0001.txt, Data_0002.txt, etc. to display content.</div></div>';
                }
            } catch (error) {
                container.innerHTML = '<div class="post"><div class="post-content">Error loading posts: ' + error.message + '</div></div>';
            }
        }
        
        // Set up scroll observer
// Set up scroll observer
// Set up scroll observer
// Set up scroll observer
function setupScrollObserver() {
    window.addEventListener('scroll', () => {
        const posts = document.querySelectorAll('.post[data-youtube]');
        const windowCenter = window.innerHeight / 2;
        
        posts.forEach(post => {
            const rect = post.getBoundingClientRect();
            
            // If the top of the post is near the middle of screen
            if (rect.top < windowCenter && rect.bottom > windowCenter) {
                const youtubeId = post.dataset.youtube;
                if (youtubeId && youtubeId !== currentVideoId) {
                    currentVideoId = youtubeId;
                    document.getElementById('ytPlayer').src = `https://www.youtube.com/embed/${youtubeId}?autoplay=1&loop=1&playlist=${youtubeId}&controls=1&modestbranding=1`;
                }
            }
        });
    });
}
        
        // Load posts
        loadPosts();
    </script>
</body>
</html>




